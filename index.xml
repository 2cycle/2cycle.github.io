<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ecycle on ecycle</title>
    <link>https://2cycle.github.io/</link>
    <description>Recent content in ecycle on ecycle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Tue, 26 Feb 2019 18:27:39 +0900</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bastion</title>
      <link>https://2cycle.github.io/2019/bastion/</link>
      <pubDate>Tue, 26 Feb 2019 18:27:39 +0900</pubDate>
      
      <guid>https://2cycle.github.io/2019/bastion/</guid>
      <description>

&lt;h1 id=&#34;bastion-적용기&#34;&gt;Bastion 적용기&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;AWS VPC&lt;/p&gt;

&lt;p&gt;AWS의 VPC(Virtual Private Cloud) 서비스는 가상의 네트워크 환경을 구성케하는 서비스이다.&lt;/p&gt;

&lt;p&gt;이 서비스를 통해 Private Network와. public Network 환경을 디자인 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Instance를 생성할 때 Security group로만 접근을 제어하는 방안을 사용하곤 했는데, 실 서비스를 운영하면서 네트워크 접근의 보안을 위해 bastion 구성을 도입했고 일부분 구축한 경험을 정리해보고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&#34;715&#34; alt=&#34;bastion&#34; src=&#34;https://user-images.githubusercontent.com/17693443/53405157-91aaae00-39fa-11e9-9588-7231403501ba.png&#34;&gt;&lt;/p&gt;

&lt;p&gt;Bastion (번역 - 요새)서비스는 bastion host를 통해 다른 VM에 ssh로 연결하게 하는 보안 방법이기 때문에 public subnet에 위치해야하고 방화벽 및 보안 정책을 적용시켜야한다.&lt;/p&gt;

&lt;p&gt;bastion을 통해 ssh 접근 보안 방식은 여러 방법이 있겠지만 한 가지 방안을 정리해보면&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;bastion 서버에서 ssh key를 생성 후 복사&lt;/li&gt;
&lt;li&gt;각 운영서버의 .ssh/authorized_keys 파일 내에 bastion public key를 복사&lt;/li&gt;
&lt;li&gt;운영서버의 inbound정책을 bastion으로만 설정&lt;/li&gt;
&lt;li&gt;Bastion 에서 접근을 편하게 하기 위해 hosts를 등록하고, bashrc에서 server alias를 등록&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;을 통해 bastion서버 설정을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;출처 - &lt;a href=&#34;http://tenmilesquare.com/using-ssh-through-a-bastion-host-transparently/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://tenmilesquare.com/using-ssh-through-a-bastion-host-transparently/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ssl파일 만료일자 모니터링</title>
      <link>https://2cycle.github.io/2019/ssl_monitering/</link>
      <pubDate>Wed, 23 Jan 2019 18:49:00 +0900</pubDate>
      
      <guid>https://2cycle.github.io/2019/ssl_monitering/</guid>
      <description>

&lt;h2 id=&#34;ssl-만료-확인&#34;&gt;SSL 만료 확인&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s encrypt를 쓰면 자동 연장이 되지만 3개월마다 갱신이 되는 것에 대한 불안감과 1년 내로 사라질 서버들이기에&amp;hellip;&lt;/p&gt;

&lt;p&gt;간단히 ssl 인증이 만료되는 것을 방지하기위해 간단히 shell script를 만들어서 crontab에 등록해놓았다.&lt;/p&gt;

&lt;p&gt;스크립트는 아주 간단한데&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;먼저 ssl 위치를 확인하고 인증 만료 시간을 확인한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;   $ openssl x509 -in /etc/httpd/conf/ssl/인증서.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;오늘 날짜를 가지고와서 notAfter 타임과 비교하여 차이를 구한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;조건 일자 이상인 경우 알림을 알린다. (필자의 경우 curl을 통해 post콜을 하였다.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

data=`echo | openssl x509 -in /etc/httpd/conf/ssl/log.cresendo.net.crt -noout -dates | grep notAfter | sed -e &#39;s#notAfter=##&#39;`

#echo &amp;quot;${data}&amp;quot;

diffdays=300
ssldate=`date -d &amp;quot;${data}&amp;quot; &#39;+%s&#39;`
nowdate=`date &#39;+%s&#39;`
diff=&amp;quot;$((${ssldate}-${nowdate}))&amp;quot;
ex_days=&amp;quot;$((${diff}/3600/24))&amp;quot;
#echo &amp;quot;${diff}&amp;quot;
#echo &amp;quot;${ex_days}&amp;quot;

if [ ${diff} -lt $((${diffdays}*24*3600)) ]
then
    if [ ${diff} -gt 0 ]
    then
        curl -H &amp;quot;Content-Type: application/json&amp;quot; \
-d &#39;{&amp;quot;title&amp;quot;:&amp;quot;WARNING!! LOG SERVER  SSL WILL BE EXPIRE&amp;quot;, &amp;quot;message&amp;quot;:&amp;quot;The LOG SERVER certificate will expried in &#39;&amp;quot;${ex_days}&amp;quot;&#39; days&amp;quot;, &amp;quot;sendTo&amp;quot; : [&amp;quot;test@test.com&amp;quot;] }&#39; \
-k EMAIL_API_SERVER_URL
    fi
fi

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 커맨드 v2</title>
      <link>https://2cycle.github.io/2019/linuxcommand_2/</link>
      <pubDate>Wed, 23 Jan 2019 18:29:03 +0900</pubDate>
      
      <guid>https://2cycle.github.io/2019/linuxcommand_2/</guid>
      <description>

&lt;h2 id=&#34;crontab&#34;&gt;crontab&lt;/h2&gt;

&lt;p&gt;현재 실행중인 crontab list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# crontab -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Crontab 편집&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# crontab -e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 입력하면 vi처럼 편집할 수 있는 화면이 생긴다.&lt;/p&gt;

&lt;p&gt;여기서 필요한 job들을 추가한 후 :wq로 저장하면 자동으로 crontab 에 job이 추가된다.&lt;/p&gt;

&lt;h3 id=&#34;job설정&#34;&gt;job설정&lt;/h3&gt;

&lt;h5 id=&#34;주기-결정&#34;&gt;주기 결정&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; *		*		*		*		*
(분)   (시간)    (일)	 (월)	(요일)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;분, 시간, 일 ,월, 요일 순이며 요일의 경우 0과 7이 일요일이며 1부터 월요일, 6이 토요일이다.&lt;/p&gt;

&lt;h5 id=&#34;주기-예제&#34;&gt;주기 예제&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * *
매분 실행

0 0 * * *
매일 자정 실행

0,30 * * 1-5
월요일부터 금요일까지 매시간 0분, 30분마다 실행

*/10 * * * * 
매 10분 마다 실행

*/10 22,23 5-10 * * 
5일에서 10일까지 22시, 23시 매 10분마다 실행
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;job-example&#34;&gt;job example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * * /root/test/test.sh
test.sh를 매 분마다 실행
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;logging&#34;&gt;logging&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * * /root/test/test.sh &amp;gt; /var/log/test/test.sh.log 2&amp;gt;&amp;amp;1
test.sh.log에 파일이 매분마다 경신됨

* * * * * /root/test/test.sh &amp;gt;&amp;gt; /var/log/test/test.sh.log 2&amp;gt;&amp;amp;1
로그 누적해서 쌓음

* * * * * /root/test/test.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
로그 안쌓음

 2&amp;gt;&amp;amp;1이란?
 n &amp;gt;&amp;amp;m : 표준 출력과 표준 에러를 서로 바꾸는 것이다.
 0: 표준 입력 , 1: 표준 출력, 2: 표준에러를 의미한다.
 즉 2&amp;gt;&amp;amp;1이란 표준 에러를 표준 출력이 전달되는 곳으로 전달! 이라는 의미이다. (표준 입력의 경우 &amp;lt;&amp;amp;0)
 
 조금 더 들어가면 /dev/null 은 /dev/null로 출력하므로 출력이 안보이기에 로그를 남기지 않는 것입니다.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고&lt;/p&gt;

&lt;p&gt;jdm.kr/blog/2&lt;/p&gt;

&lt;p&gt;www.adminschoice.com/crontab-quick-reference&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 커맨드 v1</title>
      <link>https://2cycle.github.io/2019/linuxcommand_1/</link>
      <pubDate>Wed, 23 Jan 2019 17:41:10 +0900</pubDate>
      
      <guid>https://2cycle.github.io/2019/linuxcommand_1/</guid>
      <description>

&lt;p&gt;요 근래 회사에서 주로 진행한 업무는 check_mk 모니터링 및 SSL 만료확인용 shell script 를 만드는 것이었다.&lt;/p&gt;

&lt;p&gt;리눅스 사용시 몇 개의 익숙한 명령문만 사용하였지만, 이번에 사용한 여러 명령문을 정리해보려고 한다.&lt;/p&gt;

&lt;h2 id=&#34;리눅스-커널-확인&#34;&gt;리눅스 커널 확인&lt;/h2&gt;

&lt;h4 id=&#34;getconf&#34;&gt;getconf&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;getcong utility shall write to the standard output the value of the variable spcified by the system_var operand&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;즉 시스템 환경변수를 확인할 수 있는 명령문이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;-v&lt;/strong&gt; [path_var, pathname, system_var]&lt;/p&gt;

&lt;p&gt;아마도 구성된 변수를 결정하는 specific한 사양이나 버전을 표시하는 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# getconf LONG_BIT
 &amp;gt; 32 or 64 
 각 os의 비트 값을 출력한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;arch&#34;&gt;arch&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# arch
 &amp;gt; i386 or i686 or x86_64
 i363,i686의 경우 32비트이다. 2015 macpro mid 기준 i386
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uname&#34;&gt;uname&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# uname -m
 &amp;gt; x86_64
 -a : 모든 정보
 -s : systeom OS 정보
 -n : 호스트 이름 정보
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고&lt;/p&gt;

&lt;p&gt;linux.die.net/man/1/getconf&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;Https://zetawiki.com/wiki/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Https://zetawiki.com/wiki/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EffectiveJava_Item_2</title>
      <link>https://2cycle.github.io/2019/effectivejava_item_2/</link>
      <pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://2cycle.github.io/2019/effectivejava_item_2/</guid>
      <description>

&lt;h2 id=&#34;effective-java-3-e-chapter-2&#34;&gt;Effective Java 3/e Chapter 2.&lt;/h2&gt;

&lt;h3 id=&#34;item-2-생성자-매개변수가-많다면-빌드를-고려하라&#34;&gt;Item 2. 생성자 매개변수가 많다면 빌드를 고려하라&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;점층적 생성자 패턴 (telescoping constructor pattern)

&lt;ul&gt;
&lt;li&gt;필수 매개변수 생성자 + 선택 매개변수의 갯수에 맞는 생성자를 늘려가는 방식&lt;/li&gt;
&lt;li&gt;매개변수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;public class NutritionFacts {
    priavte fianl int test1;
    priavte fianl int test2;
    priavte fianl int test3;
    priavte fianl int test4;
    
    public NutritionFacts(int test1, int test2){
        this(test1,test2,0);
    }
    public NutritionFacts(int test1, int test2, int test3){
        this(test1, test2, test3, 0);
    }
    
    ...
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;자바빈즈 패턴 (JavaBeans pattern)

&lt;ul&gt;
&lt;li&gt;매개변수가 없는 생성자로 객체를 만든 후, 세터(setter) 메서드를 호출하여 값 설정&lt;/li&gt;
&lt;li&gt;객체가 완성되기 전까지 일관성이 무너진 상태에 놓임&lt;/li&gt;
&lt;li&gt;클래스를 불면으로 만들 수 없음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;NutritionFacts cocaCola = nw NutritionFacts();
cocaCola.setTest1(1);
cocaCola.setTest2(2);
cocaCola.setTest3(3);
cocaCola.setTest4(4);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;빌더 패턴 (Builder pattern)

&lt;ul&gt;
&lt;li&gt;필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻고, 빌더 객체가 제공하는 세터 메서드로 선택 매개변수들 설정&lt;/li&gt;
&lt;li&gt;쓰기 쉽고, 읽기 쉽다.&lt;/li&gt;
&lt;li&gt;계층적으로 설계된 클래스와 함께 쓰기에 좋다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Nu&#34;&gt;public class NutritionFacts {
    //필수
    private final int servingSize;
    private final int servings;
    //옵션
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    private NutritionFacts(Builder builder) {
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
        this.sodium = builder.sodium;
        this.carbohydrate = builder.carbohydrate;
    }

    public static class Builder {
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int calories) {
            this.calories = calories;
            return this;
        }

        public Builder fat(int fat) {
            this.fat = fat;
            return this;
        }


        public Builder sodium(int sodium) {
            this.sodium = sodium;
            return this;
        }

        public Builder carbohydrate(int carbohydrate) {
            this.carbohydrate = carbohydrate;
            return this;
        }


        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Basic.java&#34;&gt;public class Item02Basic {
    public static void main(String[] args) {
        NutritionFacts cocaCola = new NutritionFacts.Builder(240,8)
                .calories(100)
                .sodium(35)
                .carbohydrate(27)
                .build();
        log.info(&amp;quot;cocaCola : {}&amp;quot;, cocaCola);

        NutritionFacts2 cocaCola2 = NutritionFacts2.builder()
                .servingSize(240)
                .servings(8)
                .calories(100)
                .sodium(35)
                .carbohydrate(27)
                .build();
        log.info(&amp;quot;cocaCola2 : {}&amp;quot;, cocaCola2);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제 소스 출처 : &lt;a href=&#34;https://github.com/bnpdukim/effective-java-3e/tree/master/src/main/java/study/effective/ch02/item02/basic&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/bnpdukim/effective-java-3e/tree/master/src/main/java/study/effective/ch02/item02/basic&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EffectiveJava_Item_5</title>
      <link>https://2cycle.github.io/2019/effectivejava_item_5/</link>
      <pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://2cycle.github.io/2019/effectivejava_item_5/</guid>
      <description>

&lt;h2 id=&#34;effective-java-3-e-chapter-2&#34;&gt;Effective Java 3/e Chapter 2.&lt;/h2&gt;

&lt;h3 id=&#34;item-5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라&#34;&gt;Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;인스턴스를 생성할 때 생성자에게 필요한 자원을 넘겨주는 방식

&lt;ul&gt;
&lt;li&gt;불변을 보장하여 여러 클라이언트가 공유하여 사용 가능&lt;/li&gt;
&lt;li&gt;의존 객체 주입은 생성자, 정적 팩터리, 빌더 모두 응용 가능&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;생성자에 자원 팩터리를 넘겨주는 방식

&lt;ul&gt;
&lt;li&gt;팩터리 메서드 패턴 (Factory Method pattern 구현)&lt;/li&gt;
&lt;li&gt;Java8 Supplier&lt;T&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Mosaic.java

import java.util.function.Supplier;
import java.util.stream.IntStream;

@Slf4j
public class Mosaic {
    private final Tile tile;

    private Mosaic(Tile tile) {
        this.tile = tile;
    }

    public void print() {
        IntStream.range(1,10)
                .forEach( i -&amp;gt; {
                    IntStream.range(1,i).forEach(i2-&amp;gt;System.out.print(tile.tile()));
                    System.out.println();
                } );
    }

    public static Mosaic create(Supplier&amp;lt;? extends Tile&amp;gt; tileFactory ) {
        return new Mosaic(tileFactory.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Tile.java

public class Tile {
    private final String tile;
    public Tile(String tile) {
        this.tile = tile;
    }
    public String tile() {
        return tile;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Item05.java

import java.util.function.Supplier;

public class Item05 {
    public static void main(String[] args) {
        Mosaic aMosaic1 = Mosaic.create(new Supplier&amp;lt;Tile&amp;gt;() {
            @Override
            public Tile get() {
                return new Tile(&amp;quot;a&amp;quot;);
            }
        });
        Mosaic aMosaic = Mosaic.create(() -&amp;gt; new Tile(&amp;quot;a&amp;quot;));
        aMosaic.print();

        Mosaic bMosaic = Mosaic.create(() -&amp;gt; new Tile(&amp;quot;b&amp;quot;));
        bMosaic.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;의존 객체 주입은 유연성, 재사용성, 테스트 용이성을 개선해준다.&lt;/p&gt;

&lt;p&gt;예제코드 출처 : &lt;a href=&#34;https://github.com/bnpdukim/effective-java-3e/blob/master/src/main/java/study/effective/ch02/item05/Tile.java&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/bnpdukim/effective-java-3e/blob/master/src/main/java/study/effective/ch02/item05/Tile.java&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effective JAVA 정리 chapter / item 1 </title>
      <link>https://2cycle.github.io/2019/effectivejava_item_1/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://2cycle.github.io/2019/effectivejava_item_1/</guid>
      <description>

&lt;h2 id=&#34;effective-java-3-e-chapter-2&#34;&gt;Effective Java 3/e  Chapter 2.&lt;/h2&gt;

&lt;h3 id=&#34;item-1-생성자-대신-정적-팩터리-메서드를-고려하라&#34;&gt;Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라&lt;/h3&gt;

&lt;h4 id=&#34;장점&#34;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;이름을 가질 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;생성자에 넘기는 매개변수와 생성자 자체만으로는 반환된 객체의 특성을 제대로 설명하지 못한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 표시할 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;  BinInteger(int , int , Random) vs BigInteger.probablePrime( int, Random)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;  Boolean.valueOf(boolean)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바 8 이전에는 interface 에 companion class(인스턴스화 불가 동반 클레스)가 필요하였다. (Ex Collection)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;자바 8부터는 interface 내에 정적 메서드를 가질 수 있어 default method 활용 가능&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;   EnumSet 클래스는 원소(매개변수) 갯수에 따라
   64개 이하 - RegularEnumSet 인스턴스(long변수 하나로 관리),
   65개 이상 - JumboEnumSet의 인스턴스(long배열로 관리) 를 반환한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;서비스 제공자 프레임워크(service provider framework)를 만드는 근간 (ex JDBC)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ex&#34;&gt;  서비스 제공자 프레임워크에서 provider는 서비스 구현체. 이 구현체들을 따라 클라이언트에서 제공하는 역할을 프레임워크가 통제하야, 클라이언트를 구현체로부터 분리
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;단점&#34;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

&lt;ul&gt;
&lt;li&gt;컴포지션을 사용하도록 유도&lt;/li&gt;
&lt;li&gt;생성자의 경우 보통 private으로 만듬&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

&lt;ul&gt;
&lt;li&gt;자바독이 알아서 처리할 수 없으므로 API정리를 잘 해놔야하고 규약에 따라 메서드 이름을 정리&lt;/li&gt;
&lt;li&gt;from&lt;/li&gt;
&lt;li&gt;of&lt;/li&gt;
&lt;li&gt;valueOf&lt;/li&gt;
&lt;li&gt;instance&lt;/li&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;getType&lt;/li&gt;
&lt;li&gt;newType&lt;/li&gt;
&lt;li&gt;type&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생성자를 사용시에 무분별하게 public 생성자를 사용하였는데, 이 책의 시작이었던 Item1을 읽으면서 조금 부끄러웠다.&lt;/p&gt;

&lt;p&gt;Item 90까지 읽으면 부끄럽지 않은 코딩을 할 수 있을까.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Who am I</title>
      <link>https://2cycle.github.io/about/</link>
      <pubDate>Thu, 03 Jan 2019 19:20:53 +0900</pubDate>
      
      <guid>https://2cycle.github.io/about/</guid>
      <description>&lt;p&gt;Want, Will be a programmer.&lt;/p&gt;

&lt;p&gt;Time is not on my side.&lt;/p&gt;

&lt;p&gt;go hard, go ambitious.&lt;/p&gt;

&lt;p&gt;Lights wiil guide you home.&lt;/p&gt;

&lt;p&gt;I will try to fix you.&lt;/p&gt;

&lt;p&gt;Seoul / male / ecycle.hello@gmail.com&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Init</title>
      <link>https://2cycle.github.io/2019/init/</link>
      <pubDate>Thu, 03 Jan 2019 18:22:41 +0900</pubDate>
      
      <guid>https://2cycle.github.io/2019/init/</guid>
      <description>&lt;p&gt;시작했다.
2주동안 테마고르고 지우고 고르고 지우고 반영안돼서 지우고 하다가 간단히 쓰려고 이렇게 만들었다.&lt;/p&gt;

&lt;p&gt;앞으로 주 2회 업로드를 목표로 블로그를 시작한다.&lt;/p&gt;

&lt;p&gt;첫 단추를 잘 꿰었길.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2cycle.github.io/1/%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%85%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2cycle.github.io/1/%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC-%E1%84%85%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%A8/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## Spring Rest Docs

### 도입 

```text
Spring REST Docs makes use of snippets produced by tests written with Spring MVC’s test framework, Spring WebFlux’s WebTestClient or REST Assured 3. This test-driven approach helps to guarantee the accuracy of your service’s documentation. 
If a snippet is incorrect the test that produces it will fail.
```
&amp;gt; 테스트 지향적인 접근 방법은 서비스 Document의 정확성을 보장하는데 도움을 준다.

Spring MVC test를 통한 정보를 통해서 문서 조각(snippet)을 모아셔 api document를 만드는 툴
Asciidoctor 를 사용하여 HTML을 생성.
테스트랑 통합하는 방법에는 mockmvc, webTestClient 등을 사용해서 가능하다.

Requirements 
 - java 8
 - Spring framework 5

```java
private MockMvc mockMvc;

@Autowired
private WebApplicationContext context;

@Before
public void setUp() {
   this.mockMvc = MockMvcBuilders.webAppContextSetup(this.context)
         .apply(documentationConfiguration(this.restDocumentation)) 
         .build();
} //documentationConfiguration 메소드에 restDccumentation을 넣어서 사용.

스프링 부트에서는 @AutoconfigureRestDocs 사용해서 편하게 사용 가능
```

### 설정 정보
- restdocs 의존성 추가
- asciidoctor 플러그인 추가
- spring-restdocs-asciidoctor 의존성 추가 &amp;gt; snippet이 자동으로 구성됨
- /target/classes/static/docs 경로에 문서가 생성됨.
- 기본 snippet (curl-request, http-request, http-response, httepie-request, request-body, reponse-body)

### Test코드 확인
MemberControllerTest.java

### adoc파일 작성
테스트코드 기반으로 snippet을 문서로 만들기 위해선 .adoc 파일을 만들어 줘야합니다. - 뼈대를 잡음.
- src/main/asciidoc/ 경로에 .adoc 파일을 생성하고 snippet을 추가해야함

### snippet 템플릿
- 디폴트 템플릿 &amp;gt; /target/test-classes/org/springframework/restdocs/templates/asciidoctor/request-fields.snippet
- Custom tempate을 만들고 싶을 경우 &amp;gt; src/test/resources/org/springframework/restdocs/templates/request-fields.snippet 에 추가하면 된다.

### Swagger vs RestDocs
 - Swagger
    - swagger의 경우 API 호출을 쉽게 해볼 수 있는 것(API 테스트)에 초점이 맞춰짐(명세기능이 일부분임)
    - 테스트 화면을 제공하고, 적용하기가 쉽다.
    - 실제 production 코드에 어노테이션이 추가되어야 하는 등 코드량이 증가한다.
    - 해당 코드는 주석의 역할만 하기 때문에 수정 갱신이 잘 이뤄지지 않으면 코드가 일치하지 않음.
 - Rest Docs
    - 제품 코드에 영향이 없다.
    - Test 가 통과해야 문서 작성이 이뤄지기에 실제 코드와 일치성이 높다.
    - Production 코드에 추가되는 내용이 없다.
  &amp;gt; 고로 API명세용으로는 Spring Rest Docs가 낫다
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>